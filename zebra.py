"""Tools for analyzing Zebra motion capture data from FRC Competitions.
"""

import argparse
import copy
import json
import urllib.error

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

import tba

def setup_parser():
    """Setup module for command-line use."""
    desc = (
        'Tools for obtaining and analyzing Zebra motion capture data '
        'collected at FIRST Robotic Competition (FRC) events.')
    parser = argparse.ArgumentParser(description=desc)
    subparsers = parser.add_subparsers()
    download_subparser = subparsers.add_parser(
        'download',
        description='Download match data from TBA')
    download_subparser.add_argument(
        'key', help='TBA district key or 4-digit year')
    download_subparser.add_argument(
        'file', help='Match data will be saved to this file.')
    download_subparser.add_argument('--max-no-path-matches',
        type=int, default=5,
        help=('Minimum number of matches checked for path data '
              'before skipping event'))
    download_subparser.set_defaults(func=download_data)
    return parser


def download_data(key, file, max_no_path_matches=5):
    """Downloads motion capture data and match scores from TBA."""

    def _event_keys():
        print()
        print('Downloading events for:', key)
        event_keys = tba.get_events(key, option='keys')
        for event_key in event_keys:
            print('Processing event:', event_key)
            yield event_key

    def _match_path_data():
        for event_key in _event_keys():
            no_path_matches = 0
            has_path_data = False
            match_keys = tba.get_match_keys(event_key)
            for match_key in match_keys:
                try:
                    zdata = tba.get_zebra(match_key)
                    score_data = tba.get_match_scores(match_key)
                    has_path_data = True
                    no_path_matches = 0
                except urllib.error.HTTPError:
                    yield event_key, match_key, None, None,
                    no_path_matches += 1
                    if (no_path_matches > max_no_path_matches and
                            not has_path_data):
                        break
                    else:
                        continue
                yield event_key, match_key, zdata, score_data

    with open(file, 'wt') as zfile:
        for event_key, match_key, zdata, score_data in _match_path_data():
            match_data = {'event': event_key,
                          'match': match_key,
                          'zebra': zdata,
                          'score': score_data}
            zfile.write(json.dumps(match_data) + '\n')


class Match():
    """Zebra path data and detailed scores for a single FRC match.

    Constructor Args:
        match_text: A single line of JSON text from the data file
            generated by the `zebra.download_data()` function. The JSON
            text consists of a dictionary with four keys: 'event',
            'match', 'zebra', and 'score'.
    """
    def __init__(self, match_json):
        if isinstance(match_json, str):
            match_json = json.loads(match_json)
        self.event = match_json['event']
        self.match = match_json['match']
        self.blue = [team['team_key']
                     for team in match_json['zebra']['alliances']['blue']]
        self.red = [team['team_key']
                    for team in match_json['zebra']['alliances']['red']]
        paths = []
        for alliance in ['blue', 'red']:
            for team in match_json['zebra']['alliances'][alliance]:
                for axis in ['xs', 'ys']:
                    paths.append(team[axis])
        self.paths = np.array(paths)
        self.times = np.array(match_json['zebra']['times'])
        self.score = match_json['score']
        
        teams_list = self.blue + self.red
        stations = ['blue1', 'blue2', 'blue3', 'red1', 'red2', 'red3']
        self.teams = {}
        for idx, tm in enumerate(teams_list):
            x_path_idx = 2*idx
            y_path_idx = 2*idx + 1
            team_data = self._scan_path(self.paths[x_path_idx],
                                        self.paths[y_path_idx])
            team_data['xs'] = self.paths[x_path_idx]
            team_data['ys'] = self.paths[y_path_idx]
            team_data['station'] = stations[idx]
            self.teams[tm] = team_data

    @staticmethod
    def _scan_path(xs, ys):
        if all([x is None for x in xs]) and all([y is None for y in ys]):
            return {'start': None, 'end': None, 'n': 0, 'missing': None}
        
        missing_coords = []
        for t, coords in enumerate(zip(xs, ys)):
            if coords[0] is None or coords[1] is None:
                missing_coords.append(t)
        
        for t, coords, in enumerate(zip(xs, ys)):
            if coords[0] is not None and coords[1] is not None:
                start = (coords[0], coords[1], t)
                break
        for t, coords, in enumerate(zip(np.flip(xs), np.flip(ys))):
            if coords[0] is not None and coords[1] is not None:
                end = (coords[0], coords[1], len(xs) - t)
                break
                
        return {'start': start,
                'end': end,
                'n': len(xs) - len(missing_coords),
                'missing': missing_coords}
                

class Competitions():
    """Zebra position data and scores for one or more FRC competitions.

    A `zebra.Competitions` object contains `zebra.Match` objects for
    one or more competitions. Use standard Python indexing notation
    (i.e., square brackets) to access individual `zebra.Match` object.
    The index value can be a positive integer or a Blue Alliance match
    key.
    For example:
        ```
        zc = zebra.Competitions('data_file.jsonl')
        zmatch1 = zc['2020wasno_qm1']

        num_matches = len(zc)
        zmatch2 = zc[num_matches - 1]
        ```
    """
    def __init__(self, file):
        """Initializes a zebra.Competitions object.

        The Competitions object is initialized from a JSONL text file
        produced by the `zebra.download()` function. See the
        documentation for `zebra.download()` for additional information
        on the format of the JSONL file.

        Args:
            file: String containing path to zebra position data. The
            file path should be suitable for Python's built-in `open()`
            function.
        """
        self.event_summary = None
        self.zmatches = None
        self._read_file(file)
        self.mindex = {zm.match: idx for idx, zm in enumerate(self.zmatches)}
        
    def __getitem__(self, idx):
        """Retrieves Match object from integer or TBA match key."""
        if isinstance(idx, int):
            return self.zmatches[idx]
        else:
            return self.zmatches[self.mindex[idx]]
    
    def __len__(self):
        """Returns number of matches in Competitions object."""
        return len(self.zmatches)
    
    def _read_file(self, file):
        """Reads data from JSONL source file."""
        # Convert file data to JSON, assumes file not too big for memory.
        with open(file) as jlfile:
            self.paths = [json.loads(line) for line in jlfile]
        
        # Create Event Summary DF, shows all events checked for zebra data
        events = [path['event'] for path in self.paths]
        matches = [path['match'] for path in self.paths]
        zebra = [ 0 if path['zebra'] is None else 1 for path in self.paths]
        self.event_summary = (
            pd.DataFrame({'event': events, 'match': matches, 'path': zebra})
            .groupby('event')
            .agg(path_matches=('path', 'sum'))
        )
        
        # Remove matches with no Zebra path data
        self.zmatches = [Match(path) for path in self.paths
                        if path['zebra'] is not None]


field2020 = {
    'game': 'Infinite Recharge',
    'colors': {
        'blue_tape': 'lightblue',
        'red_tape': 'mistyrose',
        'perimeter': 'black',
        'white_tape': 'lightgrey',
        'blue_alliance': 'blue',
        'red_alliance': 'red'
    },
    'dimenstions': 'feet',
    'lines': [
        {'x': [0, 52.438], 'y': [0, 0], 'class': 'perimeter',
         'desc': 'sidewall'},
        {'x': [52.438, 52.438], 'y': [0, 26.938], 'class': 'blue_alliance',
         'desc': 'blue_alliance_wall'},
        {'x': [0, 52.438], 'y': [26.938, 26.938], 'class': 'perimeter',
         'desc': 'sidewall'},
        {'x': [0, 0], 'y': [0, 26.938], 'class': 'red_alliance',
         'desc': 'red_alliance_wall'},

        {'x': [10, 10], 'y': [0, 26.938], 'class': 'white_tape',
         'desc': 'initiation_line'},
        {'x': [42.438, 42.438], 'y': [0, 26.938], 'class': 'white_tape',
         'desc': 'initiation_line'},

        {'x': [0, 2.5], 'y': [21.049, 19.049], 'class': 'blue_tape',
         'desc': 'blue_target_zone'},
        {'x': [2.5, 0], 'y': [19.049, 17.049], 'class': 'blue_tape',
         'desc': 'blue_target_zone'},
        {'x': [52.438, 49.938], 'y': [9.888, 7.888], 'class': 'red_tape',
         'desc': 'red_target_zone'},
        {'x': [49.938, 52.438], 'y': [7.888, 5.888], 'class': 'red_tape',
         'desc': 'red_target_zone'},

        {'x': [0, 2.5], 'y': [10.388, 7.888], 'class': 'red_tape',
         'desc': 'red_loading_zone'},
        {'x': [2.5, 0], 'y': [7.888, 5.388], 'class': 'red_tape',
         'desc': 'red_loading_zone'},
        {'x': [52.438, 49.938], 'y': [21.549, 19.049], 'class': 'blue_tape',
         'desc': 'blue_loading_zone'},
        {'x': [49.938, 52.438], 'y': [19.049, 16.549], 'class': 'blue_tape',
         'desc': 'blue_loading_zone'},
    
        {'x': [21.964, 35.885], 'y': [4.062, 9.823], 'class': 'red_tape',
         'desc': 'shieldgen_btm'},
        {'x': [35.885, 30.474], 'y': [9.823, 22.875], 'class': 'white_tape',
         'desc': 'shieldgen_blueside'},
        {'x': [30.474, 16.552], 'y': [22.875, 17.115], 'class': 'blue_tape',
         'desc': 'shieldgen_top'},
        {'x': [16.552, 21.964], 'y': [17.115, 4.062], 'class': 'white_tape',
         'desc': 'shieldgen_redside'},

        {'x': [17.219, 17.219], 'y': [0, 4.625], 'class': 'red_tape',
         'desc': 'red_trench_left'},
        {'x': [17.219, 35.219], 'y': [4.625, 4.625], 'class': 'red_tape',
         'desc': 'red_trench_top'},
        {'x': [35.219, 35.219], 'y': [4.625, 0], 'class': 'red_tape',
         'desc': 'red_trench_right'},
        {'x': [17.219, 17.219], 'y': [26.938, 22.355], 'class': 'blue_tape',
         'desc': 'blue_trench_left'},
        {'x': [17.219, 35.219], 'y': [22.355, 22.355], 'class': 'blue_tape',
         'desc': 'blue_trench_btm'},
        {'x': [35.219, 35.219],  'y': [22.355, 26.938], 'class': 'blue_tape',
         'desc': 'blue_trench_right'}
    ]}

def plot_paths(zpath, blue_tape='lightblue', red_tape='mistyrose',
               col_sides='black', col_neutral='lightgrey', blue='blue',
               red='red', figsize=(16, 9)):

    def _add_line(axes, xs, ys, color):
        axes.add_artist(matplotlib.lines.Line2D(xs, ys, color=color))

    fig, ax = plt.subplots(figsize=figsize)
    fig.tight_layout()
    ax.set_axis_off()
    # Field Perimieter
    _add_line(ax, [0, 52.438], [0, 0], col_sides)
    _add_line(ax, [52.438, 52.438], [0, 26.938], blue)
    _add_line(ax, [0, 52.438], [26.938, 26.938], col_sides)
    _add_line(ax, [0, 0], [0, 26.938], red)
                  
    # Initiation Lines
    _add_line(ax, [10, 10], [0, 26.938], col_neutral)
    _add_line(ax, [42.438, 42.438], [0, 26.938], col_neutral)
    
    # Target Zones
    _add_line(ax, [0, 2.5], [21.049, 19.049], blue_tape)
    _add_line(ax, [2.5, 0], [19.049, 17.049], blue_tape)
    _add_line(ax, [52.438, 49.938], [9.888, 7.888], red_tape)
    _add_line(ax, [49.938, 52.438], [7.888, 5.888], red_tape)
    
    # Loading Zones
    _add_line(ax, [0, 2.5], [10.388, 7.888], red_tape)
    _add_line(ax, [2.5, 0], [7.888, 5.388], red_tape)
    _add_line(ax, [52.438, 49.938], [21.549, 19.049], blue_tape)
    _add_line(ax, [49.938, 52.438], [19.049, 16.549], blue_tape)
    
    # Shield Generator
    _add_line(ax, [21.964, 35.885], [4.062, 9.823], red_tape)
    _add_line(ax, [35.885, 30.474], [9.823, 22.875], col_neutral)
    _add_line(ax, [30.474, 16.552], [22.875, 17.115], blue_tape)
    _add_line(ax, [16.552, 21.964], [17.115, 4.062], col_neutral)
    
    # Trenches
    _add_line(ax, [17.219, 17.219], [0, 4.625], red_tape)
    _add_line(ax, [17.219, 35.219], [4.625, 4.625], red_tape)
    _add_line(ax, [35.219, 35.219], [4.625, 0], red_tape)
    _add_line(ax, [17.219, 17.219], [26.938, 22.355], blue_tape)
    _add_line(ax, [17.219, 35.219], [22.355, 22.355], blue_tape)
    _add_line(ax, [35.219, 35.219], [22.355, 26.938], blue_tape)

    def _plot_path(axes, xs, ys, pcolor, lbl):
        axes.plot(xs, ys, color=pcolor, label=lbl )
        
    path_colors = ['darkblue', 'royalblue', 'deepskyblue',
                   'darkred', 'crimson', 'lightcoral']
    
    labels = zpath.blue + zpath.red
    for idx in range(6):
        _plot_path(ax, zpath.paths[2*idx], zpath.paths[2*idx + 1],
                   path_colors[idx], labels[idx])
        
    ax.set_aspect('equal')
    ax.set_xlim(-1, 55)
    ax.set_ylim(-1, 27)
    title = zpath.match
    ax.legend()
    ax.set_title(title)


if __name__ == '__main__':
    parser = setup_parser()
    args = parser.parse_args()
    subcommand = args.func
    del args.func
    subcommand(**vars(args))
